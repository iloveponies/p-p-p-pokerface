(if (= "as" nil) "aaaa" "no good))
(if (= "as" nil) "aaaa" "no good)
(if (=4 2) "asa" "noo")
(if (= 4 2) "asa" "noo")
(if (= 4 4) "asa" "noo")
clear
cls
( Math/random 12)
(Math/sqrt 144)
(Math/sqrt 256)
(Math/sqrt 512)
(Math/IEEEremainder (/ 12 23))
(Math/IEEEremainder 34)
(repeat "as")
(repeat "as" 3)
(repeat 3 "as")
(repeat "as")
(take 8 repeat "as")
(take 8 (repeat "as"))
(concat  (repeat 8 "na"))
(concat  (repeat 8 "na")) "BATMAN")
(concat  (repeat 8 "na") "BATMAN")
(concat  (repeat 8 "na") str "BATMAN")
(concat  (repeat 8 "na") (str "BATMAN"))
(concat  (repeat 8 "na") ["BATMAN"])
(type concat  (repeat 8 "na") ["BATMAN"])
(type (concat  (repeat 8 "na") ["BATMAN"]))
man juxt
help juxt
(doc juxt)
(juxt [a b c] "a")
(juxt ["a" "b" "c"] "a")
(->( juxt ["a" "b" "c"] "a"))
(->(juxt ["a" "b" "c"] "a"))
(-> (juxt ["a" "b" "c"] "a"))
(apply str (juxt ["a" "b" "c"] "a"))
(juxt ["a" "b" "c"] "a")
exit
(replace {4 0} range 1 5)
(replace {4 0} (range 1 5))
(defn rank [card] (let [ [r _] card] (if (Character/isDigit r) (Integer/valueOf (str r)) (replacement (str r)))))
(def replacement {"T" 10 "J" 11 "Q" 12 "K" 13 "A" 14})
(defn rank [card] (let [ [r _] card] (if (Character/isDigit r) (Integer/valueOf (str r)) (replacement (str r)))))
(defn straight? [hand] (map card hand))
(defn straight? [hand] (map rank hand))
(def high-seven                   ["2H" "3S" "4C" "5C" "7D"])
(def pair-hand                    ["2H" "2S" "4C" "5C" "7D"])
(def two-pairs-hand               ["2H" "2S" "4C" "4D" "7D"])
(def three-of-a-kind-hand         ["2H" "2S" "2C" "4D" "7D"])
(def four-of-a-kind-hand          ["2H" "2S" "2C" "2D" "7D"])
(def straight-hand                ["2H" "3S" "6C" "5D" "4D"])
(def low-ace-straight-hand        ["2H" "3S" "4C" "5D" "AD"])
(def high-ace-straight-hand       ["TH" "AS" "QC" "KD" "JD"])
(def flush-hand                   ["2H" "4H" "5H" "9H" "7H"])
(def full-house-hand              ["2H" "5D" "2D" "2C" "5S"])
(def straight-flush-hand          ["2H" "3H" "6H" "5H" "4H"])
(def low-ace-straight-flush-hand  ["2D" "3D" "4D" "5D" "AD"])
(def high-ace-straight-flush-hand ["TS" "AS" "QS" "KS" "JS"])
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (min map-number) max-card (max map-number)] [min-card max-card]))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] [min-card max-card]))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] [count hand]))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] [(count hand)]))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) replace {(count hand) 0} hand)))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {(count hand) 0} hand))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {(count hand) 0} map-number))))
(straight? low-ace-straight-hand)
(replace {0 1} [2 3 4])
(replace {2 1} [2 3 4])
(replace { 2 1 } [2 3 4])
(replace {2 1} [2 3 4])
(replace {2 1}[2 3 4])
(replace{2 1}[2 3 4])
(replace{1 3}[2 3 4])
(replace{1 4}[2 3 4])
(doc replace)
(replace {1 2} [1 2 3])
(replace {0 4} [1 2 3])
(replace {1 4} [1 2 3])
(replace {2 4} [1 2 3])
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {(+ 1 (count hand)) 0} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {(- 1 (count hand)) 0} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {5 0} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {4 0} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 0} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 0} map-number))))
(replace {1 0} [1 2 3])
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 0} (seq map-number))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 0} (seq map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) "hay que reemplazar" )))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (type map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) ( vec(map-number))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) ( vec(map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) ( vec map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {5 0} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {6 0} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {4 0} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 0} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {0 0} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} vec map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq map-number)))))
(replace {1 "as"} [1 2 3 4])
(replace {2 "as"} [1 2 3 4])
(seq 
(seq '(1 2 3 4))
(vec '(1 2 3 4))
(seq '(1 2 3 4))
(replace {1 "a"} (seq '(1 2 3 4)))
(replace {3 "a"} (seq '(1 2 3 4)))
(replace {5 "a"} (seq '(1 2 3 4)))
(replace {4 "a"} (seq '(1 2 3 4)))
(type (seq '(1 2 3 4)))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq 'map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} 'map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq map-number))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (seq map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (type (seq map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (type (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (type (list map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (list map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} list map-number)))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} list map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (list map-number))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (list map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (vec map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {1 "a"} (seq map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {5 "a"} hand))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (replace {3 "a"} hand))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace {3 "a"} hand)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace {3 "a"} map-number)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace {3 "a"} (seq map-number))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace {1 "a"} (seq map-number))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace {0 "a"} (seq map-number))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (type (seq map-number))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (type (vec map-number))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (replace (vec map-number) 4 0)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (-> (assoc (vec map-number) 4 0)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (filter (fn [x] (not (= x max-card))) map-number))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (= card-array (range (min-card (+ max-arr 1))))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (-> card-array)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (-> max-arr)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (range min-card max-arr)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (range min-card (+ max-arr 1)))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (range min-card (+ max-arr 1))))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (= (range min-card (+ max-arr 1)) card-array)))))
(straight? low-ace-straight-hand)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (= (range min-card (+ max-arr 1)) (sort card-array))))))
(straight? low-ace-straight-hand)
(straight? two-pairs-hand)
(straight? ["2H" "2D" "3H" "4H" "5H"])
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (> (- max-card min-card) 4) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (= (range min-card (+ max-arr 1)) (sort card-array))) (= (sort map-number) (range min-card (+ max-card 1))))))
(straight? ["2H" "2D" "3H" "4H" "5H"])
(defn flush? [hand] (= 1 (count (keys (frequencies (map (fn [pair] (let [ [n f] pair] (str f))) hand))))))
(defn straight-flush? [hand] (and (flush? hand) (straight? hand)))
(straight-flush? flush-hand)
(straight-flush? high-ace-straight-hand)
(straight? high-ace-straight-hand)
(flush? high-ace-straight-hand)
(flush? straight-flush-hand)
(straight? straight-flush-hand)
(straight? low-ace-straight-hand)
(straight? high-ace-straight-flush-hand)
(second "ki")
(defn high-card? [hand]
(defn high-card? [hand] true)
(let [checkers #{[high-card? 0]  [pair? 1]
                 [two-pairs? 2]  [three-of-a-kind? 3]
                 [straight? 4]   [flush? 5]
                 [full-house? 6] [four-of-a-kind? 7]
                 [straight-flush? 8]}])
(defn value [hand] ( (let [checkers #{[high-card? 0]  [pair? 1]
                 [two-pairs? 2]  [three-of-a-kind? 3]
                 [straight? 4]   [flush? 5]
                 [full-house? 6] [four-of-a-kind? 7]
                 [straight-flush? 8]}])
)
(defn value [hand] ( (let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3]
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]))
(defn pair? [hand] (if(> ( apply max (vals (frequencies  (map (fn [x] (let [[n s] x] n)) hand )))) 1) true false))
(defn three-of-a-kind? [pair] (contains? (set(vals (frequencies (map (fn [one] (let [[num lettr] one] (str num)))  pair)))) 3))
(defn two-pairs? [hand] (let [first-group
 26                                     (frequencies (map (fn [x] (let [[n s] x] s)) hand))]
 27                                  (let [max-symbol  (key (apply max-key val first-group)) ]
 28                                       (let [candidate-map (filter (fn [h] (let [[ n s] h]
 29                                              (not (= s max-symbol)))) hand)
 30                                              real-map (filter (fn [x1] (let [ [n1 s1] x1](= s1 max-symbol))) hand )]
 31                                               (let [number (map (fn [f] ( let [[x1 y1] f] x1)) real-map)]
 32                                                   (not (empty? (filter (fn [x] (let [[xm ym] x] (not (nil? (some #{xm} number))))) candidate-map))))))))
 26                                     (frequencies (map (fn [x] (let [[n s] x] s)) hand))]
(defn two-pairs? [hand] (let [first-group
                                      (frequencies (map (fn [x] (let [[n s] x] s)) hand))]
                                   (let [max-symbol  (key (apply max-key val first-group)) ]
                                        (let [candidate-map (filter (fn [h] (let [[ n s] h]
                                              (not (= s max-symbol)))) hand)
                                               real-map (filter (fn [x1] (let [ [n1 s1] x1](= s1 max-symbol))) hand )]
                                                (let [number (map (fn [f] ( let [[x1 y1] f] x1)) real-map)]
                                                    (not (empty? (filter (fn [x] (let [[xm ym] x] (not (nil? (some #{xm} number))))) candidate-map))))))))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]))
(defn full-house? [hand] (let [fre  (frequencies (map (fn [pair] (let [[n h] pair] (str n))) hand))] (if (or (> (count (keys fre)) 2) (< (count (keys fre)) 2)) false (if (and (= (apply + (vals fre)) 5) (not (nil? (some #{3} (vals fre))))) true false))))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]))
(defn four-of-a-kind?[pair] (contains? (set(vals (frequencies (map (fn [one] (let [[num lettr] one] (str num)))  pair)))) 4))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (->type checkers))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (->type checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (-> type checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (-> checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (map checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (map checkers hand)))
(flush? flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (map checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? % 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (map checkers hand)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (three-of-a-kind?  hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (map hand checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (juxt checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (-> juxt checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (type checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (apply checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}] (apply (keys checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (map checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (type checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (:hight-card? checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (:two-pairs? checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (apply hand checkers )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (apply checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (apply hand checkers )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  ( hand checkers )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  ( filter checkers hand )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  ( filter hand checkers )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (-> hand )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (-> keys chekcers )))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (-> keys checkers )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (doseq checkers hand )))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (doseq [checkers] hand )))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (doseq checkers hand )))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (reduce checkers hand )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (reduce checkers hand )))
(doc reduce)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (apply checkers hand )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (apply [checkers] hand )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (get checkers 1 )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (get checkers 0 )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (keys checkers  )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (type checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (:high-card? checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [straight-flush? 8]}]  (:1 checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [map (fn [x] (x? hand) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  [map (fn [x] (x? hand) checkers))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  (map (fn [x] (x? hand)) checkers))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]  (map (fn [x] (x? hand)) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [x] (x? hand)) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [x] (x hand)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (keys checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (keys checkers))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (keys checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (type checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map #{hand} checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map #{hand %} checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map #{hand} checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map first checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply  (map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ((map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map first checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (second checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (first checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map first checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (map first checkers) hand))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (filter (map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply (map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ((map  apply first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( filter first checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( filter (map first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( filter (first checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply first checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map first checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map hand checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [x] (x hand)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map {:key checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( {:key checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( {:keys checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  ( {:keys checkers} )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (-> {:keys checkers} )))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply {:keys checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map {:keys checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply {:keys checkers} hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply checkers hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map #(apply checkers) hand)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f coll] (map#(apply f%1))) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f coll] (map #(apply f%1))) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f coll] (map #(apply f%1)) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [[f coll]] ( apply f hand)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] ( (first f hand)) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] ( first f hand)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] ( (first f) hand)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] (if( (first f) hand)) second f) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] (if ((first f) hand) second f) checkers)))
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] (if ((first f) hand) second f)) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (map (fn [f] (if ((first f) hand) (second f))) checkers)))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (filter (fn [x] (not (nil? x))) (map (fn [f] (if ((first f) hand) (second f))) checkers))))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply max (filter (fn [x] (not (nil? x))) (map (fn [f] (if ((first f) hand) (second f))) checkers)))))
(value flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7]}]  (apply max (filter (fn [x] (not (nil? x))) (map (fn [f] (if ((first f) hand) (second f))) checkers)))))
(value straight-flush-hand)
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7] [straight-flush? 8]}]  (apply max (filter (fn [x] (not (nil? x))) (map (fn [f] (if ((first f) hand) (second f))) checkers)))))
(value straight-flush-hand)
(value high-seven)
(straight? high-seven)
(-> high-seven)
(straight? high-seven)
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (and (> (- max-card min-card) 4) (= max-card 14)) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-    array)] (= (range min-card (+ max-arr 1)) (sort card-array))) (= (sort map-number) (range min-card (+ max-card 1))))))
(defn straight? [hand] (let [map-number (map rank hand) min-card (apply min map-number) max-card (apply max map-number)] (if (and (> (- max-card min-card) 4) (= max-card 14)) (let [card-array  (filter (fn [x] (not (= x max-card))) map-number) max-arr (apply max card-array)] (= (range min-card (+ max-arr 1)) (sort card-array))) (= (sort map-number) (range min-card (+ max-card 1))))))
(straight? high-seven)
(every? (partial = 1) (map value pair-hands)) 
(def pair-hands #{["2H" "2S" "4C" "5C" "7D"]
                  ["2S" "4S" "4C" "9D" "KS"]})
(every? (partial = 1) (map value pair-hands)) 
(value pair-hand)
(value pair-hands)
(-> pair-hands)
(every? (partial = 1) (map value pair-hands)) 
(defn value [hand] ( let [checkers #{[high-card? 0]  [pair? 1]  [two-pairs? 2]  [three-of-a-kind? 3] [straight? 4]   [flush? 5]  [full-house? 6] [four-of-a-kind? 7] [straight-flush? 8]}]  (apply max (filter (fn [x] (not (nil? x))) (map (fn [f] (if ((first f) hand) (second f))) checkers)))))
(value pair-hands) 
(value pair-hand) 
(map value pair-hands) 
(->pair-hands) 
(-> pair-hands) 
(two-pairs? ["2S" "4S" "4C" "9D" "KS"])
(defn rank [card] (let [ [r _] card] (if (Character/isDigit r) (Integer/valueOf (str r)) (replacement (str r)))))
(defn two-pairs?? [hand] (map rank hand))
(two-pairs?? two-pairs-hand)
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (frequencies (map rank hand)))
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (vals (frequencies (map rank hand))))
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (filter (fn [x] (>= x 2)) vals (frequencies (map rank hand))))
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand)))))
(two-pairs?? pair-hand)
(two-pairs?? two-pair-hand)
(two-pairs?? two-pairs-hand)
(defn two-pairs?? [hand] (>= 2 (count filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand))))))
(defn two-pairs?? [hand] (>= 2 (count (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand)))))))
(two-pairs?? two-pairs-hand)
(two-pairs?? pairs-hand)
(two-pairs?? pair-hand)
(two-pairs?? pair-hand))
(two-pairs?? pair-hand)
(-> pair-hand)
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (count (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand))))))
(two-pairs?? pair-hand)
(two-pairs?? two-pairs-hand)
(defn two-pairs?? [hand] (> 1 (count (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand)))))))
(two-pairs?? two-pairs-hand)
(two-pairs?? pair-hand)
(two-pairs?? two-pairs-hand)
(defn two-pairs?? [hand] (count (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand))))))
(two-pairs?? two-pairs-hand)
(two-pairs?? pair-hand)
(defn two-pairs?? [hand] (> (count (filter (fn [x] (>= x 2)) (vals (frequencies (map rank hand))))) 1)) 
(two-pairs?? pair-hand)
(two-pairs?? two-pairs-hand)
